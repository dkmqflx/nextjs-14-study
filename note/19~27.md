## [Next.js 14 Tutorial - 19 - Link Component Navigation](https://nextjs.org/docs/app/api-reference/components/link)

- [replace](https://nextjs.org/docs/app/api-reference/components/link#replace)

  - replace prop replaces the current history state instead of adding a new URL

<br/>

## Next.js 14 Tutorial - 20 - Active Links

- [usePathname](https://nextjs.org/docs/app/api-reference/functions/use-pathname)

<br/>

## Next.js 14 Tutorial - 21 - Navigating Programmatically

- [useRouter](https://nextjs.org/docs/app/api-reference/functions/use-router)

<br/>

## Next.js 14 Tutorial - 22 - Templates

- layout 파일에 아래처럼 state가 정의되어 있는 경우, 같은 layout을 같는 다른 경로로 이동하더라도 state가 유지된다

- 예를들어 input에 값을 입력ㄷ한 다음 Link 클릭해서 다른 url로 이동하더라도 input에 입력한 state가 유지 된다

```tsx
// layout.tsx

const [state, setState] = useState()


...

<input onChnage={(e) => setState(e.target.value)}>

```

### [Templates](https://nextjs.org/docs/app/building-your-application/routing/layouts-and-templates#templates)

- 하지만 이와 달리 아래와 같이 template 파일에서 다른 경로로 이동하게 되면 상태가 보존되지 않기 때문에 input 안의 state는 초기화 된다

```tsx
// template.tsx

const [state, setState] = useState()


...

<input onChnage={(e) => setState(e.target.value)}>

```

- Templates are similar to layouts in that they wrap a child layout or page.

- But, with templates, when a user navigates between routes that share a template, a new instance of the component is mounted, DOM elements are recreated, state is not preserved, and effects are re-synchronized

- A template can be defined by exporting a default React component from a template.js or template.tsx file

- Similar to layout, templates also should accept a children prop which will render the nested segments in the route

<br/>

## [Next.js 14 Tutorial - 23 - Loading UI](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#instant-loading-states)

### loading.tsx

- This file allows us to create loading states that are displayed to users while a specific route segment's content is loading

- The loading state appears immediately upon navigation, giving users the assurance that the application is responsive and actively loading content

### loading.tsx Benefits

1. You can display the loading state as soon as a user navigates a new route

   - The immediate feedback reassures users that their action has been acknowledged, reduces perceived loading times, and makes the application feel more responsive

2. Next.js allows the creation of shared layouts that remain interactive while new route segments are loading

   - Users can continue interacting with certain parts of the application, such as a navigation menu or sidebar, even if the main content is still being fetched

<br/>

## [Next.js 14 Tutorial - 24 - Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling#using-error-boundaries)

```tsx
"use client"; // Error boundaries must be Client Components

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

### error.tsx

- Automatically wrap a route segment and its nested children in a React Error Boundary

- Crate error UI tailored to specific segments using the file-system hierarchy to adjust granularity

- Isolate errors to affected segments while keeping the rest of the application functional

- Add functionality to attempt to recover from an error without a full page reload

<br/>

## [Next.js 14 Tutorial - 26 - Handling Errors in Nested Routes](https://nextjs.org/docs/app/building-your-application/routing/error-handling#using-error-boundaries)

### Handling Errors in Nested Routes

- Errors bubble up to the closet parent error boundary

- An error.tsx file will cater to errors for all its nested child segments

- By positioning error.tsx files at different levels in the nested folders of a route, you can achieve a more granular level of error handling

<br/>

## Next.js 14 Tutorial - 24 - Error Handling

### Handling Errors in Layouts

- An error.tsx file will handle errors for all its nested child segments

- The error boundary does not catch errors thrown here
  because it's nested inside the layouts component

- 즉, nested layout 의 경우에, nested layout 외부에 error 파일을 만들어주면, nested layout에서 에러가 발생하더라도 error 파일에서 처리할 수 있다.
